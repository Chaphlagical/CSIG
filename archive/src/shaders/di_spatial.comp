#version 460
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_ray_query : enable
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_shader_explicit_arithmetic_types : enable
#extension GL_EXT_buffer_reference : enable
#extension GL_EXT_buffer_reference2 : enable

#define NUM_THREADS_X 8
#define NUM_THREADS_Y 8

#include "restir_common.glsl"
#include "gbuffer_data.glsl"
#include "scene.glsl"
#include "raytrace.glsl"
#include "bxdf.glsl"

layout (local_size_x = NUM_THREADS_X, local_size_y = NUM_THREADS_Y, local_size_z = 1) in;

layout(push_constant) uniform PushConstants
{
	uint64_t passthrough_reservoir_addr;
	uint64_t spatial_reservoir_addr;
    uint spatial_reuse;
    float radius;
    uint samples;
}push_constants;

void main()
{
    const ivec2 coord = ivec2(gl_GlobalInvocationID.xy);
    const ivec2 size = textureSize(gbufferA, 0);
    const uint pixel_id = coord.x * size.y + coord.y;

    if(coord.x >= size.x || coord.y >= size.y)
    {
        return;
    }

    RestirReservoirBuffer(push_constants.spatial_reservoir_addr).reservoirs[pixel_id] = init_reservoir();
    barrier();

    prd.seed = tea(size.x * gl_GlobalInvocationID.y + gl_GlobalInvocationID.x, uint(ubo.cam_pos.w));

    Reservoir r = RestirReservoirBuffer(push_constants.passthrough_reservoir_addr).reservoirs[pixel_id];

    ShadeState sstate;

    if (push_constants.spatial_reuse == 1 && 
        get_primary_state(vec2(coord) + vec2(0.5), 0, sstate) &&
        dot(sstate.ffnormal, sstate.ffnormal) != 0)
    {
        for (int i = 0; i < push_constants.samples; i++) 
        {
            // Choose a neighbor pixel
            const float angle = rand(prd.seed) * 2 * PI;
            const float radius = sqrt(rand(prd.seed)) * push_constants.radius;
            ivec2 rand_offset = ivec2(floor(cos(angle) * radius), floor(sin(angle) * radius));
            const ivec2 neighbor_coord = clamp(ivec2(coord.xy) + rand_offset, ivec2(0), ivec2(size.xy) - 1);
            ShadeState neighbor_sstate;
            if(get_primary_state(vec2(neighbor_coord) + vec2(0.5), 0, neighbor_sstate))
            {
                vec3 pos_diff = sstate.position - neighbor_sstate.position;
                if(dot(pos_diff, pos_diff) < 0.01 && abs(sstate.depth - neighbor_sstate.depth) < sstate.depth * 0.1)
                {
                    vec3 base_color_diff = sstate.mat.base_color.rgb - neighbor_sstate.mat.base_color.rgb;
                    if(dot(base_color_diff, base_color_diff) < 0.01)
                    {
                        float normal_dot = dot(sstate.ffnormal, neighbor_sstate.ffnormal);
                        if(normal_dot > 0.9063)
                        {
                            const int neighbor_idx = neighbor_coord.x * size.y + neighbor_coord.y;
                            const Reservoir r_neightbor = get_reservoir(push_constants.passthrough_reservoir_addr, neighbor_idx);
                            if(r_neightbor.num_samples > 0)
                            {
                                float p_hat = eval_phat(r_neightbor.light_id, sstate);
                                combine_reservoir(r, r_neightbor, p_hat);
                            }
                        }
                    }
                }
            }                
        }      
    }

    RestirReservoirBuffer(push_constants.spatial_reservoir_addr).reservoirs[pixel_id] = r;
}