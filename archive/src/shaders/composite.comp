#version 460
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_ray_query : enable
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_shader_explicit_arithmetic_types : enable
#extension GL_EXT_buffer_reference : enable
#extension GL_EXT_buffer_reference2 : enable

#include "scene.glsl"
#include "bxdf.glsl"
#include "gbuffer_data.glsl"
#include "raytrace.glsl"
#include "spherical_harmonic.glsl"

#define NUM_THREADS_X 8
#define NUM_THREADS_Y 8

layout (local_size_x = NUM_THREADS_X, local_size_y = NUM_THREADS_Y, local_size_z = 1) in;

layout(set = 2, binding = 0) uniform sampler2D ggx_preintegration;
layout(set = 3, binding = 0, rgba16f) uniform writeonly image2D output_image;
layout(set = 3, binding = 1) uniform sampler2D direct_lighting;
layout(set = 3, binding = 2) uniform sampler2D reflection_lighting;
layout(set = 3, binding = 3) uniform sampler2D ao_image;
layout(set = 3, binding = 4) uniform sampler2D gi_image;

layout(push_constant) uniform PushConstants
{
    int mode;
}push_constants;

vec3 fresnel_schlick_roughness(float cos_theta, vec3 F0, float roughness)
{
    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(max(1.0 - cos_theta, 0.0), 5.0);
}

vec3 indirect_lighting(ShadeState sstate, Ray ray, ivec2 coord)
{
    const vec3 R = normalize(reflect(ray.direction, sstate.ffnormal));
    const vec3 F0 = mix(vec3(0.04), sstate.mat.base_color.rgb, sstate.mat.metallic_factor);
    vec3 F = fresnel_schlick_roughness(max(dot(sstate.ffnormal, -ray.direction), 0.0), F0, sstate.mat.roughness_factor);
    
    vec3 ks = F;
    vec3 kd = 1.0 - ks;
    kd *= 1.0 - sstate.mat.metallic_factor;

    // vec3 irradiance = vec3(0.0);
    // SH9 basis = evaluate_sh(sstate.ffnormal);
    // for (uint i = 0; i < 9; i++)
    // {
    //     irradiance += texelFetch(irradiance_sh, ivec2(i, 0), 0).rgb * basis.weights[i];
    // }
    // irradiance = max(vec3(0), irradiance) * InvPI;
    vec3 irradiance = texelFetch(gi_image, coord, 0).rgb;
    vec3 diffuse = irradiance * sstate.mat.base_color.rgb;
    vec3 prefiltered_color = texelFetch(reflection_lighting, coord, 0).rgb;
    // vec3 prefiltered_color = textureLod(prefilter_map, R, sstate.mat.roughness_factor * PREFILTER_MIP_LEVELS).rgb;
    vec2 brdf = textureLod(ggx_preintegration, vec2(clamp(abs(dot(-ray.direction, sstate.ffnormal)), 0.0, 1.0), sstate.mat.roughness_factor), 0).rg;
    vec3 specular = prefiltered_color * (F * brdf.x + brdf.y);
    return (kd * diffuse + specular) * texelFetch(ao_image, coord, 0).r;
}

void main()
{
    const ivec2 coord = ivec2(gl_GlobalInvocationID.xy);
    const ivec2 size = textureSize(gbufferA, 0);
    const vec2 pixel_center = vec2(coord) + vec2(0.5);
    const vec2 tex_coord = pixel_center / vec2(size);

	prd.seed = tea(size.x * gl_GlobalInvocationID.y + gl_GlobalInvocationID.x, uint(ubo.cam_pos.w));

    vec3 radiance = vec3(0.0);

    ShadeState sstate;
    bool is_hit = get_primary_state(vec2(coord) + vec2(0.5), 0, sstate);
    Ray ray;
    ray.origin = ubo.cam_pos.xyz;
	ray.direction = normalize(sstate.position - ubo.cam_pos.xyz);

    if(is_hit)
    {
        if(push_constants.mode == 0)
        {
            radiance += texelFetch(direct_lighting, coord, 0).rgb;
            radiance += indirect_lighting(sstate, ray, coord);
        }
        else if(push_constants.mode == 1)
        {
            radiance = vec3(texelFetch(ao_image, coord, 0).r);
        }
        else if(push_constants.mode == 2)
        {
            radiance = texelFetch(gi_image, coord, 0).rgb;
        }
        else if(push_constants.mode == 3)
        {
            radiance = texelFetch(reflection_lighting, coord, 0).rgb;
        }
        else if(push_constants.mode == 4)
        {
            radiance = texelFetch(direct_lighting, coord, 0).rgb;
        }
    }
    else
    {
        if(push_constants.mode == 0)
        {
            radiance += textureLod(skybox, ray.direction, 0).rgb;
        }
    }
    imageStore(output_image, coord, vec4(radiance, 1.0));
}