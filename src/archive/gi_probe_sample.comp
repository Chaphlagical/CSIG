#version 460

#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_ray_query : enable
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_shader_explicit_arithmetic_types : enable

#include "common.glsl"
#include "ddgi.glsl"

#define NUM_THREADS_X 8
#define NUM_THREADS_Y 8

layout(local_size_x = NUM_THREADS_X, local_size_y = NUM_THREADS_Y, local_size_z = 1) in;

layout(binding = 0, scalar) uniform UBO
{
    GlobalData ubo;
};

layout(binding = 1, scalar) uniform DDGIUBO
{
    DDGIUniform ddgi_buffer;
};

layout(binding = 2) uniform sampler2D gbufferB;
layout(binding = 3) uniform sampler2D depth_buffer;
layout(binding = 4) uniform sampler2D probe_irradiance;
layout(binding = 5) uniform sampler2D probe_depth;
layout(binding = 6, rgba16f) uniform image2D output_gi;
layout(binding = 7) uniform sampler2DArray probe_data;

layout(push_constant) uniform PushConstants
{
	int gbuffer_mip;
    float gi_intensity;
}push_constants;

const float FLT_EPS = 0.00000001;

void main()
{
    const ivec2 size = textureSize(gbufferB, push_constants.gbuffer_mip);
    const vec2 texel_size = vec2(1.0) / vec2(size);
    const ivec2 current_coord = ivec2(gl_GlobalInvocationID.xy);
    const vec2 pixel_center = vec2(current_coord) + vec2(0.5);
    const vec2 tex_coord = pixel_center / vec2(size);

    float depth = texelFetch(depth_buffer, current_coord, push_constants.gbuffer_mip).r;

    if (depth == 1.0)
    {
        imageStore(output_gi, current_coord, vec4(0.0));
        return;
    }

    vec3 P  = world_position_from_depth(tex_coord, depth, ubo.view_projection_inv);
    vec3 N  = octohedral_to_direction(texelFetch(gbufferB, current_coord, push_constants.gbuffer_mip).rg);
    vec3 V = normalize(ubo.cam_pos.xyz - P);
    N = dot(N, V) > 0 ? N : -N;

    vec3 irradiance = push_constants.gi_intensity * sample_irradiance(P, N, V, ddgi_buffer, probe_depth, probe_irradiance, probe_data);

    imageStore(output_gi, current_coord, vec4(irradiance, 1.0));
}