#version 460

#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_ray_query : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_shader_explicit_arithmetic_types : enable

#include "gbuffer_data.glsl"
#include "random.glsl"
#include "sample.glsl"

#define NUM_THREADS_X 8
#define NUM_THREADS_Y 4

layout(binding = 0, scalar) uniform UBO
{
    GlobalData ubo;
};

layout(binding = 1, r32ui) uniform uimage2D raytraced_image;
layout(binding = 2) uniform sampler2D gbufferB;
layout(binding = 3) uniform sampler2D depth_buffer;
layout(binding = 4) uniform sampler2D sobol_sequence;
layout(binding = 5) uniform sampler2D scrambling_ranking_tile;
layout(binding = 6) uniform accelerationStructureEXT tlas;

layout(push_constant) uniform PushConstants
{
	float ray_length;
	float bias;
	int gbuffer_mip;
}push_constants;

layout (local_size_x = NUM_THREADS_X, local_size_y = NUM_THREADS_Y, local_size_z = 1) in;

vec2 random_sample(ivec2 coord)
{
    return vec2(sample_blue_noise(coord, int(ubo.cam_pos.w), 0, sobol_sequence, scrambling_ranking_tile),
                sample_blue_noise(coord, int(ubo.cam_pos.w), 1, sobol_sequence, scrambling_ranking_tile));
}

vec3 sample_cosine_lobe(vec3 n, vec2 rnd)
{
	rnd = max(rnd, vec2(0.00001));
	const float phi = 2.0 * PI * rnd.y;
	const float cos_theta = sqrt(rnd.x);
	const float sin_theta = sqrt(1.0 - rnd.x);
	vec3 t = vec3(sin_theta * cos(phi), sin_theta * sin(phi), cos_theta);
	return local_to_world(n, t);
}

bool any_hit(vec3 org, vec3 dir, float max_dist)
{
	rayQueryEXT ray_query;
	rayQueryInitializeEXT(
		ray_query, 
		tlas, 
		gl_RayFlagsTerminateOnFirstHitEXT | gl_RayFlagsSkipClosestHitShaderEXT | gl_RayFlagsCullBackFacingTrianglesEXT, 
		0xFF,
		org,
		0.0,
		dir,
		max_dist);

	while(rayQueryProceedEXT(ray_query))
	{
		if(rayQueryGetIntersectionTypeEXT(ray_query, false) == gl_RayQueryCandidateIntersectionTriangleEXT)
		{
			rayQueryConfirmIntersectionEXT(ray_query);
		}
	}

	return (rayQueryGetIntersectionTypeEXT(ray_query, true) != gl_RayQueryCommittedIntersectionNoneEXT);
}

shared uint shared_ao;

void main()
{
	if(gl_LocalInvocationIndex == 0)
	{
		shared_ao = 0;
	}

	barrier();

	const ivec2 size = textureSize(gbufferB, int(push_constants.gbuffer_mip));
	const ivec2 pos = ivec2(gl_GlobalInvocationID.xy);
	const vec2 pixel = vec2(pos) + vec2(0.5);
	const vec2 uv = pixel / vec2(size);

	float depth = texelFetch(depth_buffer, pos, push_constants.gbuffer_mip).r;

	uint result = 0;

	if(depth != 1.0)
	{
		vec3 world_pos = world_position_from_depth(uv, depth, ubo.view_projection_inv);
		vec3 normal = octohedral_to_direction(texelFetch(gbufferB, pos, push_constants.gbuffer_mip).rg);
		vec2 rnd = random_sample(pos);
		vec3 dir = sample_cosine_lobe(normal, rnd);
		vec3 org = world_pos + push_constants.bias * normal;
		result = uint(!any_hit(org, dir, push_constants.ray_length));
	}
	
	atomicOr(shared_ao, result << gl_LocalInvocationIndex);
	
	barrier();

	if (gl_LocalInvocationIndex == 0)
	{
		imageStore(raytraced_image, ivec2(gl_WorkGroupID.xy), uvec4(shared_ao));
	}
}