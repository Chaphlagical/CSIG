#version 460
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_ray_query : enable
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_shader_explicit_arithmetic_types : enable
#extension GL_EXT_buffer_reference : enable
#extension GL_EXT_buffer_reference2 : enable

#include "common.glsl"
#include "scene.glsl"
#include "gbuffer_data.glsl"
#include "bxdf.glsl"
#include "random.glsl"
#include "sample.glsl"
#include "raytrace.glsl"

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(set = 2, binding = 0, rgba16f) readonly uniform image2D prev_path_tracing_image;
layout(set = 2, binding = 1, rgba16f) uniform image2D path_tracing_image;

layout(push_constant) uniform PushConstants
{
	int max_depth;
	float bias;
	uint frame_count;
}push_constants;

vec3 path_trace(vec2 frag_coord)
{
	vec3 radiance   = vec3(0.0);
  	vec3 throughput = vec3(1.0);
	Ray ray;
	for(uint trace_depth = 0; trace_depth < push_constants.max_depth; trace_depth++)
	{
		ShadeState sstate;
		bool is_hit = false;
		if(trace_depth == 0)
		{
			is_hit = get_primary_state(frag_coord, 0, sstate);
			ray.origin = ubo.cam_pos.xyz;
			ray.direction = normalize(sstate.position - ubo.cam_pos.xyz);
		}
		else
		{
			is_hit = closest_hit(ray);
			sstate = get_shade_state(ray, prd);
		}

		if(!is_hit)
		{
			radiance += textureLod(skybox, ray.direction, 0).rgb * throughput;
			break;
		}

		radiance += sstate.mat.emissive_factor * throughput;

		LightSample ls = sample_light(ray, sstate, push_constants.bias, prd.seed);
		if(ls.visible)
		{
			radiance += ls.radiance * throughput;
		}

		BSDFSample bs = sample_bsdf(sstate, -ray.direction, prd.seed);

		if(bs.pdf > 0.0)
		{
			throughput *= bs.f * abs(dot(sstate.ffnormal, bs.L)) / bs.pdf;
		}
		else
		{
			break;
		}

		float rrPcont = (trace_depth >= 3) ?
					min(max(throughput.x, max(throughput.y, throughput.z)) * sstate.eta * sstate.eta + 0.001, 0.95) :
					1.0;

		if(rand(prd.seed) >= rrPcont)
		{
			break;
		}

		throughput /= rrPcont;

		ray.direction = bs.L;
		ray.origin = sstate.position + push_constants.bias * (dot(bs.L, sstate.ffnormal) > 0 ? sstate.ffnormal : -sstate.ffnormal);
	}

	float lum = dot(radiance, vec3(0.212671, 0.715160, 0.072169));
	if(lum > 1.0)
	{
		radiance *= 1.0 / lum;
	}

	return radiance;
}

void main()
{
	const ivec2 size = textureSize(gbufferA, 0);
	const ivec2 coord = ivec2(gl_GlobalInvocationID.xy);

	prd.seed = tea(size.x * gl_GlobalInvocationID.y + gl_GlobalInvocationID.x, push_constants.frame_count * push_constants.max_depth);

	const vec2 jittered_coord = vec2(coord) + rand2(prd.seed);
	const vec2 tex_coord = jittered_coord / vec2(size);
	const vec2 tex_coord_neg_to_pos = tex_coord * 2.0 - 1.0;

	vec3 pixel_color = path_trace(vec2(coord) + vec2(0.5));

	if(push_constants.frame_count == 0)
	{
		imageStore(path_tracing_image, ivec2(gl_GlobalInvocationID.xy), vec4(pixel_color, 1));
	}
	else
	{
		if(!any(isnan(pixel_color)))
		{
			vec3 prev_color = imageLoad(prev_path_tracing_image, ivec2(gl_GlobalInvocationID.xy)).rgb;
			vec3 accumulated_color = mix(prev_color, pixel_color, 1.0 / float(push_constants.frame_count));
			imageStore(path_tracing_image, ivec2(gl_GlobalInvocationID.xy), vec4(accumulated_color, 1));
		}
	}
}
