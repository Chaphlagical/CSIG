#version 460
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_ray_query : enable
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_shader_explicit_arithmetic_types : enable
#extension GL_EXT_buffer_reference : enable
#extension GL_EXT_buffer_reference2 : enable

#include "scene.glsl"
#include "gbuffer_data.glsl"
#include "bxdf.glsl"
#include "random.glsl"
#include "sample.glsl"
#include "raytrace.glsl"

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(set = 2, binding = 0, rgba16f) readonly uniform image2D prev_path_tracing_image;
layout(set = 2, binding = 1, rgba16f) uniform image2D path_tracing_image;

layout(push_constant) uniform PushConstants
{
	int max_depth;
	float bias;
	uint frame_count;
}push_constants;

vec3 path_trace(vec2 frag_coord)
{
	vec3 radiance   = vec3(0.0);
  	vec3 throughput = vec3(1.0);
	Ray ray;
	bool is_hit = false;
	ShadeState sstate;
	for(uint trace_depth = 0; trace_depth < push_constants.max_depth; trace_depth++)
	{
		if(trace_depth == 0)
		{
			is_hit = get_primary_state(frag_coord, 0, sstate);
			ray.origin = ubo.cam_pos.xyz;
			ray.direction = normalize(sstate.position - ubo.cam_pos.xyz);
			radiance += sstate.mat.emissive_factor * throughput;
		}

		if(!is_hit)
		{
			radiance += textureLod(skybox, ray.direction, 0).rgb * throughput; 
			break;
		}

		LightSample ls = sample_light(sstate);
		
		{
			Ray shadow_ray;
			shadow_ray.origin = offset_ray(sstate.position, dot(ls.dir, sstate.ffnormal) > 0 ? sstate.ffnormal : -sstate.ffnormal);
			shadow_ray.direction = ls.dir;
			if(!any_hit(shadow_ray, length(shadow_ray.origin - ls.pos)))
			{
				float bsdf_pdf;
				vec3 f = eval_bsdf(sstate, -ray.direction, sstate.ffnormal, ls.dir, bsdf_pdf);
				float mis_weight = max(0.0, power_heuristic(ls.pdf, bsdf_pdf));
				radiance += throughput * mis_weight * f * ls.le * abs(dot(ls.norm, -ls.dir)) / (ls.dist * ls.dist);
			}
		}

		BSDFSample bs = sample_bsdf(sstate, -ray.direction, prd.seed);

		if(bs.pdf > 0.0)
		{
			throughput *= bs.f;
		}
		else
		{
			break;
		}

		float rrPcont = (trace_depth >= 3) ?
					min(max(throughput.x, max(throughput.y, throughput.z)) * sstate.eta * sstate.eta + 0.001, 0.95) :
					1.0;

		if(rand(prd.seed) >= rrPcont)
		{
			break;
		}

		throughput /= rrPcont;

		ray.direction = bs.L;
		ray.origin = sstate.position + push_constants.bias * (dot(bs.L, sstate.ffnormal) > 0 ? sstate.ffnormal : -sstate.ffnormal);

		is_hit = closest_hit(ray);
		sstate = get_shade_state(ray, prd);

		Instance instance = get_instance(prd.instance_custom_index);
		if(instance.emitter >= 0)
		{
			float dist_sq = dot(sstate.position - ray.origin, sstate.position - ray.origin);
			float geo_term = dot(bs.L, sstate.ffnormal) / dist_sq;
			float pdf_nee = emitter_pdf(instance.emitter) / geo_term;
			float mis_weight = (bs.pdf * bs.pdf) / (pdf_nee * pdf_nee + bs.pdf * bs.pdf);
			radiance += mis_weight * sstate.mat.emissive_factor * throughput;
		}
	}

	float lum = luminance(radiance);
	if(lum > 1.0)
	{
		radiance *= 1.0 / lum;
	}

	return radiance;
}

void main()
{
	const ivec2 size = textureSize(gbufferA, 0);
	const ivec2 coord = ivec2(gl_GlobalInvocationID.xy);

	prd.seed = tea(size.x * gl_GlobalInvocationID.y + gl_GlobalInvocationID.x, uint(ubo.cam_pos.w));

	const vec2 jittered_coord = vec2(coord) + rand2(prd.seed);
	const vec2 tex_coord = jittered_coord / vec2(size);
	const vec2 tex_coord_neg_to_pos = tex_coord * 2.0 - 1.0;

	vec3 pixel_color = path_trace(vec2(coord) + vec2(0.5));

	if(push_constants.frame_count == 0)
	{
		imageStore(path_tracing_image, ivec2(gl_GlobalInvocationID.xy), vec4(pixel_color, 1));
	}
	else
	{
		if(!any(isnan(pixel_color)))
		{
			vec3 prev_color = imageLoad(prev_path_tracing_image, ivec2(gl_GlobalInvocationID.xy)).rgb;
			vec3 accumulated_color = mix(prev_color, pixel_color, 1.0 / float(push_constants.frame_count));
			imageStore(path_tracing_image, ivec2(gl_GlobalInvocationID.xy), vec4(accumulated_color, 1));
		}
	}
}
