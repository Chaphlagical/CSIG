#ifndef COMMON_SLANGH
#define COMMON_SLANGH

static const float PI            = 3.14159265358979323846;
static const float InvPI         = 0.31830988618379067154;
static const float Inv2PI        = 0.15915494309189533577;
static const float Inv4PI        = 0.07957747154594766788;
static const float PIOver2       = 1.57079632679489661923;
static const float PIOver4       = 0.78539816339744830961;
static const float Sqrt2         = 1.41421356237309504880;
static const float ShadowEpsilon = 0.0001;
static const float Epsilon       = 1e-7;
static const float Infinity      = 1e32;

static const float CosineA0 = PI;
static const float CosineA1 = (2.0 * PI) / 3.0;
static const float CosineA2 = PI * 0.25;

#define POSITIVE_X 0
#define NEGATIVE_X 1
#define POSITIVE_Y 2
#define NEGATIVE_Y 3
#define POSITIVE_Z 4
#define NEGATIVE_Z 5

struct CSParam
{
    uint3 DispatchThreadID : SV_DispatchThreadID;
    uint3 GroupThreadID : SV_GroupThreadID;
    uint3 GroupID : SV_GroupID;
    uint GroupIndex : SV_GroupIndex;
};

struct DispatchIndirectCommand {
    uint x;
    uint y;
    uint z;
};

struct Vertex
{
	float4 position; // xyz - position, w - texcoord u
	float4 normal; // xyz - normal, w - texcoord v
};

struct View
{
	float4x4 view_inv;
	float4x4 projection_inv;
	float4x4 view_projection_inv;
	float4x4 view_projection;
	float4x4 prev_view;
	float4x4 prev_projection;
	float4x4 prev_view_projection;
	float4x4 prev_view_projection_inv;
	float4 cam_pos; // xyz - position, w - num_frames
	float4 prev_cam_pos; // xyz - position, w - padding
	float4 jitter;
};

struct Emitter
{
	float4 p0;
	float4 p1;
	float4 p2;
	float4 n0;
	float4 n1;
	float4 n2;
	float4 intensity;
};

struct Mesh
{
	uint vertices_offset;
	uint vertices_count;
	uint indices_offset;
	uint indices_count;
	uint material;
	float area;
};

struct Material
{
	uint alpha_mode; // 0 - opaque, 1 - mask, 2 - blend
	uint double_sided;
	float cutoff;
	float metallic_factor;
	float roughness_factor;
	float transmission_factor;
	float clearcoat_factor;
	float clearcoat_roughness_factor;
	float4 base_color;
	float3 emissive_factor;
	int32_t base_color_texture;
	int32_t normal_texture;
	int32_t metallic_roughness_texture;
	float2 padding;
};

struct Instance
{
    float4x4 transform;
    float4x4 transform_inv;
    uint vertices_offset;
    uint vertices_count;
    uint indices_offset;
    uint indices_count;
    uint mesh;
    uint material;
    int emitter;
    float area;
};

struct Light
{
    float3 position;
    uint instance_id;
};

struct AliasTable
{
	float prob;         // The i's column's event i's prob
	int   alias;        // The i's column's another event's idx
	float ori_prob;
	float alias_ori_prob;
};

struct Scene
{
	uint vertices_count;
	uint indices_count;
	uint instance_count;
	uint material_count;
	float3 min_extent;
	uint emitter_count;
	float3 max_extent;
    uint mesh_count;
    float3 padding;
    uint light_count;
};

struct ShadeState
{
	float3 normal;
	float3 geom_normal;
	float3 ffnormal;
	float3 position;
	float3 tangent;
	float3 bitangent;
	float eta;
	bool primary;
	float depth;
    float2 motion_vector;
    uint instance_id;
	Material mat;
};

struct SH9
{
    float weights[9];
};

struct SH9Color
{
    float3 weights[9];
};

void coordinate_system(float3 N, out float3 Nt, out float3 Nb)
{
	Nt = normalize(((abs(N.z) > 0.99999f) ? float3(-N.x * N.y, 1.0f - N.y * N.y, -N.y * N.z) :
	                                        float3(-N.x * N.z, -N.y * N.z, 1.0f - N.z * N.z)));
	Nb = normalize(cross(Nt, N));
}

float3 local_to_world(float3 n, float3 v)
{
	const float3 ref = abs(dot(n, float3(0, 1, 0))) > 0.99 ? float3(0, 0, 1) : float3(0, 1, 0);
    const float3 x = normalize(cross(ref, n));
    const float3 y = cross(n, x);
	return normalize(mul(float3x3(x, y, n), v));
}

float3 world_position_from_depth(float2 uv, float ndc_depth, float4x4 view_proj_inv)
{
    float2 screen_pos = uv * 2.0 - 1.0;
    float4 ndc_pos = float4(screen_pos, ndc_depth, 1.0);
	float4 world_pos  = mul(view_proj_inv, ndc_pos);
    world_pos = world_pos / world_pos.w;
    return world_pos.xyz;
}

float3 octohedral_to_direction(float2 e)
{
    float3 v = float3(e, 1.0 - abs(e.x) - abs(e.y));

    if (v.z < 0.0)
	{
        v.xy = (1.0 - abs(v.yx)) * (step(0.0, v.xy) * 2.0 - 1.0);
	}

    return normalize(v);
}

int2 texture_size(Texture2D<float> texture, uint mip_level)
{
	uint width, height, level;
	texture.GetDimensions(mip_level, width, height, level);
	return int2(width, height);
}

int2 texture_size(Texture2D<float4> texture, uint mip_level)
{
	uint width, height, level;
	texture.GetDimensions(mip_level, width, height, level);
	return int2(width, height);
}

int2 texture_size(Texture2D<uint> texture, uint mip_level)
{
	uint width, height, level;
	texture.GetDimensions(mip_level, width, height, level);
	return int2(width, height);
}

int2 texture_size(TextureCube<float4> texture, uint mip_level)
{
	uint width, height, level;
	texture.GetDimensions(mip_level, width, height, level);
	return int2(width, height);
}

float luminance(float3 color)
{
	return dot(color, float3(0.212671, 0.715160, 0.072169));
}

float area_integral(float x, float y)
{
    return atan2(x * y, sqrt(x * x + y * y + 1));
}

float unlerp(float val, float max_val)
{
    return (val + 0.5) / max_val;
}

SH9 project_sh(in float3 dir)
{
    SH9 sh;

    sh.weights[0] = 0.282095;

    sh.weights[1] = -0.488603 * dir.y;
    sh.weights[2] = 0.488603 * dir.z;
    sh.weights[3] = -0.488603 * dir.x;

    sh.weights[4] = 1.092548 * dir.x * dir.y;
    sh.weights[5] = -1.092548 * dir.y * dir.z;
    sh.weights[6] = 0.315392 * (3.0 * dir.z * dir.z - 1.0);
    sh.weights[7] = -1.092548 * dir.x * dir.z;
    sh.weights[8] = 0.546274 * (dir.x * dir.x - dir.y * dir.y);

    return sh;
}

float3 evaluate_sh_irradiance(float3 direction, Texture2D irradiance_sh)
{
    SH9 basis = project_sh(direction);

    basis.weights[0] *= CosineA0;
    basis.weights[1] *= CosineA1;
    basis.weights[2] *= CosineA1;
    basis.weights[3] *= CosineA1;
    basis.weights[4] *= CosineA2;
    basis.weights[5] *= CosineA2;
    basis.weights[6] *= CosineA2;
    basis.weights[7] *= CosineA2;
    basis.weights[8] *= CosineA2;

    float3 color = float3(0.0);

    for (int i = 0; i < 9; i++)
        color += irradiance_sh.Load(int3(i, 0, 0)).rgb * basis.weights[i];

    color.x = max(0.0, color.x);
    color.y = max(0.0, color.y);
    color.z = max(0.0, color.z);

    return color / PI;
}

float calculate_solid_angle(uint x, uint y, uint width, uint height)
{
    float s = unlerp(float(x), width) * 2.0 - 1.0;
    float t = unlerp(float(y), height) * 2.0 - 1.0;

    // assumes square face
    float half_texel_size = 1.0 / width;
    float x0 = s - half_texel_size;
    float y0 = t - half_texel_size;
    float x1 = s + half_texel_size;
    float y1 = t + half_texel_size;

    return area_integral(x0, y0) - area_integral(x0, y1) - area_integral(x1, y0) + area_integral(x1, y1);
}

float3 calculate_cubemap_direction(uint face, uint face_x, uint face_y, uint width, uint height)
{
    float u = unlerp(float(face_x), width) * 2.0 - 1.0;
    float v = unlerp(float(face_y), height) * 2.0 - 1.0;
    float x, y, z;

    switch (face)
    {
        case POSITIVE_X:
            x = 1;
            y = -v;
            z = -u;
            break;
        case NEGATIVE_X:
            x = -1;
            y = -v;
            z = u;
            break;
        case POSITIVE_Y:
            x = u;
            y = 1;
            z = v;
            break;
        case NEGATIVE_Y:
            x = u;
            y = -1;
            z = -v;
            break;
        case POSITIVE_Z:
            x = u;
            y = -v;
            z = 1;
            break;
        case NEGATIVE_Z:
            x = -u;
            y = -v;
            z = -1;
            break;
    }
	
    return normalize(float3(x, y, z));
}

#endif