#version 460
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_ray_query : enable
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_shader_explicit_arithmetic_types : enable
#extension GL_EXT_buffer_reference : enable
#extension GL_EXT_buffer_reference2 : enable

#include "scene.glsl"
#include "bxdf.glsl"
#include "gbuffer_data.glsl"
#define REPROJECTION_MOMENTS
#include "reproject.glsl"

#define NUM_THREADS_X 8
#define NUM_THREADS_Y 8

layout (local_size_x = NUM_THREADS_X, local_size_y = NUM_THREADS_Y, local_size_z = 1) in;

layout(push_constant) uniform PushConstants
{
    uint64_t denoise_tile_data_addr;
    uint64_t denoise_tile_dispatch_args_addr;
    uint64_t copy_tile_data_addr;
    uint64_t copy_tile_dispatch_args_addr;
    int gbuffer_mip;
    float alpha;
    float moments_alpha;
}push_constants;

layout(set = 2, binding = 0, rgba16f) uniform writeonly image2D output_image;
layout(set = 2, binding = 1, rgba16f) uniform writeonly image2D moments_image;
layout(set = 2, binding = 2) uniform sampler2D input_image;
layout(set = 2, binding = 3) uniform sampler2D history_output_image;
layout(set = 2, binding = 4) uniform sampler2D history_moments_image;

layout(buffer_reference, scalar, buffer_reference_align = 4) buffer TileDataBuffer
{
    ivec2 coord[];
};

layout(buffer_reference, scalar, buffer_reference_align = 4) buffer DispatchArgsBuffer
{
    uint num_groups_x;
    uint num_groups_y;
    uint num_groups_z;
};

vec3 clip_aabb(vec3 aabb_min, vec3 aabb_max, vec3 history_sample)
{
    vec3 aabb_center = 0.5 * (aabb_max + aabb_min);
    vec3 extent_clip = 0.5 * (aabb_max - aabb_min) + 0.001;

    vec3 color_vector = history_sample - aabb_center;
    vec3 color_vector_clip = color_vector / extent_clip;
    color_vector_clip  = abs(color_vector_clip);
    float max_abs_unit = max(max(color_vector_clip.x, color_vector_clip.y), color_vector_clip.z);

    if (max_abs_unit > 1.0)
    {
        return aabb_center + color_vector / max_abs_unit;
    }
    else
    {
        return history_sample;
    }
}

void neighborhood_standard_deviation(ivec2 coord, out vec3 mean, out vec3 std_dev)
{
    vec3 m1 = vec3(0.0);
    vec3 m2 = vec3(0.0);

    int   radius = 8;
    float weight = (float(radius) * 2.0 + 1.0) * (float(radius) * 2.0 + 1.0);

    for (int dx = -radius; dx <= radius; dx++)
    {
        for (int dy = -radius; dy <= radius; dy++)
        {
            ivec2 sample_coord = coord + ivec2(dx, dy);
            vec3  sample_color = texelFetch(input_image, sample_coord, 0).rgb;

            m1 += sample_color;
            m2 += sample_color * sample_color;
        }
    }

    mean = m1 / weight;
    vec3 variance = (m2 / weight) - (mean * mean);

    std_dev = sqrt(max(variance, 0.0f));
}

float compute_max_accumulated_frame(float history_length)
{
    if (length(ubo.cam_pos.xyz - ubo.prev_cam_pos.xyz) > 0.0)
    {
        return 8.0;
    }
    else
    {
        return history_length;
    }
}

shared uint shared_need_denoise;

void main()
{
    shared_need_denoise = 0;
    if(gl_GlobalInvocationID.x == 0 && gl_GlobalInvocationID.y == 0)
    {
        DispatchArgsBuffer(push_constants.denoise_tile_dispatch_args_addr).num_groups_x = 0;
        DispatchArgsBuffer(push_constants.denoise_tile_dispatch_args_addr).num_groups_y = 1;
        DispatchArgsBuffer(push_constants.denoise_tile_dispatch_args_addr).num_groups_z = 1;
        DispatchArgsBuffer(push_constants.copy_tile_dispatch_args_addr).num_groups_x = 0;
        DispatchArgsBuffer(push_constants.copy_tile_dispatch_args_addr).num_groups_y = 1;
        DispatchArgsBuffer(push_constants.copy_tile_dispatch_args_addr).num_groups_z = 1;
    }

    barrier();

    const ivec2 coord = ivec2(gl_GlobalInvocationID.xy);
    const ivec2 size = textureSize(gbufferA, push_constants.gbuffer_mip);
    const vec2 pixel_center = vec2(coord) + vec2(0.5);
    const vec2 tex_coord = pixel_center / vec2(size);

    const float depth = texelFetch(depth_buffer, coord, push_constants.gbuffer_mip).r;
    const float roughness = texelFetch(gbufferC, coord, push_constants.gbuffer_mip).r;

    vec4 output_radiance = vec4(0.0);
    vec4 output_moments  = vec4(0.0);

    if(depth != 0)
    {
        vec4 color_ray_length = texelFetch(input_image, coord, 0);
        vec3 color = color_ray_length.rgb;

        vec3 history_color;
        vec2 history_moments;
        float history_length;

        // reproject
        bool success = reprojection(coord,
                                 depth,
                                 push_constants.gbuffer_mip,
                                 ubo.view_projection_inv,
                                 gbufferB,
                                 gbufferC,
                                 prev_gbufferB,
                                 prev_gbufferC,
                                 prev_depth_buffer,
                                 history_output_image,
                                 history_moments_image,
                                 history_color,
                                 history_moments,
                                 history_length);

        history_length = min(32.0, success ? history_length + 1.0 : 1.0);

        if(success)
        {
            vec3 std_dev;
            vec3 mean;

            neighborhood_standard_deviation(coord, mean, std_dev);

            vec3 radiance_min = mean - std_dev;
            vec3 radiance_max = mean + std_dev;

            history_color.xyz = clip_aabb(radiance_min, radiance_max, history_color.xyz);
        }

        const float max_accumulated_frame = compute_max_accumulated_frame(history_length);
        const float alpha = success ? max(push_constants.alpha, 1.0 / max_accumulated_frame) : 1.0;
        const float alpha_moments = success ? max(push_constants.moments_alpha, 1.0 / max_accumulated_frame) : 1.0;

        vec2 moments = vec2(0.0);
        moments.r = luminance(color);
        moments.g = moments.r * moments.r;

        moments = mix(history_moments, moments, alpha_moments);

        float variance = max(0.0, moments.g - moments.r * moments.r);

        vec3 accumulated_color = mix(history_color, color, alpha);

        output_moments  = vec4(moments, history_length, 0.0);
        output_radiance = vec4(accumulated_color, variance);
    }

    imageStore(moments_image, coord, output_moments);
    imageStore(output_image, coord, output_radiance);

    if (depth != 0 && 
        roughness >= MIRROR_REFLECTIONS_ROUGHNESS_THRESHOLD &&
        roughness <= DIFFUSE_REFLECTIONS_ROUGHNESS_THRESHOLD)
    {
        shared_need_denoise = 1;
    }

    barrier();

    if (gl_LocalInvocationIndex == 0)
    {
        if(shared_need_denoise == 1)
        {
            uint idx = atomicAdd(DispatchArgsBuffer(push_constants.denoise_tile_dispatch_args_addr).num_groups_x, 1);
            TileDataBuffer(push_constants.denoise_tile_data_addr).coord[idx] = coord;
        }
        else
        {
            uint idx = atomicAdd(DispatchArgsBuffer(push_constants.copy_tile_dispatch_args_addr).num_groups_x, 1);
            TileDataBuffer(push_constants.copy_tile_data_addr).coord[idx] = coord;
        }
    }
}