#version 460

#extension GL_GOOGLE_include_directive : enable

#define REPROJECTION_SINGLE_COLOR_CHANNEL
#include "reproject.glsl"

#define NUM_THREAD_X 8
#define NUM_THREAD_Y 8
#define RAY_MASK_SIZE_X 8
#define RAY_MASK_SIZE_Y 4

layout (local_size_x = NUM_THREAD_X, local_size_y = NUM_THREAD_Y, local_size_z = 1) in;

layout(binding = 0) uniform UBO
{
	mat4 view_inv;
	mat4 projection_inv;
	mat4 view_projection_inv;
	mat4 view_projection;
	mat4 prev_view_projection;
	vec4 cam_pos;
	vec4 jitter;
} ubo;

layout(binding = 1) uniform sampler2D gbufferB;
layout(binding = 2) uniform sampler2D gbufferC;
layout(binding = 3) uniform sampler2D depth_buffer;
layout(binding = 4) uniform sampler2D prev_gbufferB;
layout(binding = 5) uniform sampler2D prev_gbufferC;
layout(binding = 6) uniform sampler2D prev_depth_buffer;
layout(binding = 7) uniform usampler2D raytraced_image;
layout(binding = 8, r16f) uniform writeonly image2D ao_image;
layout(binding = 9, r16f) uniform writeonly image2D history_length_image;
layout(binding = 10) uniform sampler2D prev_ao_image;
layout(binding = 11) uniform sampler2D prev_history_length_image;
layout(binding = 12, std430) buffer DenoiseTileBuffer
{
    ivec2 coord[];
}denoise_tile_buffer;
layout(binding = 13, std430) buffer DenoiseTileDispatchArgsBuffer
{
    uint x;
    uint y;
    uint z;
}denoise_tile_dispatch_args_buffer;

layout(push_constant) uniform PushConstants
{
    float alpha;
    int gbuffer_mip;
	uint debug;
}push_constants;

shared uint shared_ao_masks[3][6];
shared float shared_mean[8][24];
shared bool shared_denoise;

void populate_cache()
{
	shared_denoise = false;

	if(gl_LocalInvocationID.x < 3 && gl_LocalInvocationID.y < 6)
	{
		const ivec2 pos = ivec2(gl_WorkGroupID.x, gl_WorkGroupID.y * 2) - ivec2(1, 2) + ivec2(gl_LocalInvocationID.xy);
		const ivec2 size = textureSize(raytraced_image, 0);
		if(any(lessThan(pos, ivec2(0, 0))) || any(greaterThan(pos, size - ivec2(1, 1))))
		{
			shared_ao_masks[gl_LocalInvocationID.x][gl_LocalInvocationID.y] = 0xffffffff;
		}
		else
		{
			shared_ao_masks[gl_LocalInvocationID.x][gl_LocalInvocationID.y] = texelFetch(raytraced_image, pos, 0).x;
		}
	}

	barrier();
}

float unpack_ao_hit_value(ivec2 coord)
{
	const ivec2 work_group_start_coord = ivec2(gl_WorkGroupID.xy) * ivec2(NUM_THREAD_X, NUM_THREAD_Y);
	const ivec2 cache_start_coord = work_group_start_coord - ivec2(RAY_MASK_SIZE_X, RAY_MASK_SIZE_Y * 2);
	const ivec2 unpacked_cache_coord = coord - cache_start_coord;
	const ivec2 packed_cache_coord = unpacked_cache_coord / ivec2(RAY_MASK_SIZE_X, RAY_MASK_SIZE_Y);
	const ivec2 mask_start_coord = packed_cache_coord * ivec2(RAY_MASK_SIZE_X, RAY_MASK_SIZE_Y);
	const ivec2 relative_mask_coord = unpacked_cache_coord - mask_start_coord;
	const int hit_index = relative_mask_coord.y * RAY_MASK_SIZE_X + relative_mask_coord.x;
	return float((shared_ao_masks[packed_cache_coord.x][packed_cache_coord.y] >> hit_index) & 1);
}

float horizontal_neighborhood_mean(ivec2 coord)
{
	float result = 0.0;
	for(int x = -8; x <= 8; x++)
	{
		result += unpack_ao_hit_value(ivec2(coord.x + x, coord.y));
	}
	return result;
}

float neighborhood_mean(ivec2 coord)
{
	float top = horizontal_neighborhood_mean(ivec2(coord.x, coord.y - 8));
	float middle = horizontal_neighborhood_mean(ivec2(coord.x, coord.y));
	float bottom = horizontal_neighborhood_mean(ivec2(coord.x, coord.y + 8));

	shared_mean[gl_LocalInvocationID.x][gl_LocalInvocationID.y] = top;
	shared_mean[gl_LocalInvocationID.x][gl_LocalInvocationID.y + 8] = middle;
	shared_mean[gl_LocalInvocationID.x][gl_LocalInvocationID.y + 16] = bottom;

	barrier();

	const float radius = 8.0;
	const float weight = (radius * 2.0 + 1.0) * (radius * 2.0 + 1.0);

	float mean = 0.0;
	for(int y = 0; y < 16; y++)
	{
		mean += shared_mean[gl_LocalInvocationID.x][gl_LocalInvocationID.y + y];
	}
	
	return mean / weight;
}

void main()
{
	if(gl_GlobalInvocationID.x == 0 && gl_GlobalInvocationID.y == 0)
	{
		denoise_tile_dispatch_args_buffer.x = 0;
		denoise_tile_dispatch_args_buffer.y = 1;
		denoise_tile_dispatch_args_buffer.z = 1;
	}

	barrier();

	const ivec2 size = textureSize(prev_ao_image, 0);
	const ivec2 coord = ivec2(gl_GlobalInvocationID.xy);

	populate_cache();
	float mean = neighborhood_mean(coord);

	float depth = texelFetch(depth_buffer, coord, push_constants.gbuffer_mip).r;

	float ao = 1.0;
	float history_length = 0.0;

	if(depth != 1.0)
	{
		ao = unpack_ao_hit_value(coord);
		float history_ao = 0.0;
		bool success = reprojection(coord,
									depth,
									push_constants.gbuffer_mip,
									ubo.view_projection_inv,
									gbufferB,
									gbufferC,
									prev_gbufferB,
									prev_gbufferC,
									prev_depth_buffer,
									prev_ao_image,
									prev_history_length_image,
									history_ao,
									history_length);

		history_length = min(32.0, success ? history_length + 1.0 : 1.0);
		
		if(success)
		{
			float spatial_variance = mean;
			spatial_variance = max(spatial_variance - mean * mean, 0.0);
			const float std_deviation = sqrt(spatial_variance);
			const float nmin = mean - 0.5 * std_deviation;
			const float nmax = mean + 0.5 * std_deviation;
			history_ao = clamp(history_ao, nmin, nmax);
		}

		const float alpha = success ? max(push_constants.alpha, 1.0 / history_length) : 1.0;
		ao = mix(history_ao, ao, alpha);
	}

	imageStore(ao_image, coord, vec4(ao));
	imageStore(history_length_image, coord, vec4(history_length));

	if(ao < 1.0)
	{
		shared_denoise = true;
	}

	barrier();

	if(gl_LocalInvocationIndex == 0 && shared_denoise)
	{
		uint idx = atomicAdd(denoise_tile_dispatch_args_buffer.x, 1);
		denoise_tile_buffer.coord[idx] = coord;
	}
}