#version 460

#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_ray_query : enable
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_shader_explicit_arithmetic_types : enable
#extension GL_EXT_buffer_reference : enable
#extension GL_EXT_buffer_reference2 : enable

#include "gbuffer_data.glsl"
#include "random.glsl"
#include "sample.glsl"
#include "raytrace.glsl"
#include "bxdf.glsl"
#include "scene.glsl"
#include "ddgi.glsl"

#define NUM_THREADS_X 8
#define NUM_THREADS_Y 8

layout (local_size_x = NUM_THREADS_X, local_size_y = NUM_THREADS_Y, local_size_z = 1) in;

layout(set = 2, binding = 0) uniform DDGIBuffer
{
	DDGIUniform ddgi_buffer;
};

layout(set = 2, binding = 1, rgba16f) uniform image2D radiance_image;
layout(set = 2, binding = 2, rgba16f) uniform image2D direction_depth;

layout(set = 2, binding = 3) uniform sampler2D probe_irradiance;
layout(set = 2, binding = 4) uniform sampler2D probe_depth;

layout(push_constant) uniform PushConstants
{
	mat4 random_orientation;
	uint frame_count;
	uint infinite_bounce;
	float gi_intensity;
}push_constants;

ivec3 base_grid_coord(vec3 X) 
{
    return clamp(ivec3((X - ddgi_buffer.grid_start) / ddgi_buffer.grid_step), ivec3(0, 0, 0), ivec3(ddgi_buffer.probe_count) - ivec3(1, 1, 1));
}

vec3 grid_coord_to_position(ivec3 c)
{
    return ddgi_buffer.grid_step * vec3(c) + ddgi_buffer.grid_start;
}

int grid_coord_to_probe_index(ivec3 probe_coord) 
{
    return int(probe_coord.x + probe_coord.y * ddgi_buffer.probe_count.x + probe_coord.z * ddgi_buffer.probe_count.x * ddgi_buffer.probe_count.y);
}

ivec3 probe_index_to_grid_coord(int index)
{
    ivec3 pos;
	pos.x = index % ddgi_buffer.probe_count.x;
	pos.y = (index % (ddgi_buffer.probe_count.x * ddgi_buffer.probe_count.y)) / ddgi_buffer.probe_count.x;
	pos.z = index / (ddgi_buffer.probe_count.x * ddgi_buffer.probe_count.y);
    return pos;
}

vec3 probe_location(int index)
{
	ivec3 grid_coord = probe_index_to_grid_coord(index);
	return grid_coord_to_position(grid_coord);
}

vec3 spherical_fibonacci(float i, float n)
{
	const float PHI = sqrt(5.0) * 0.5 + 0.5;
#define madfrac(A, B) ((A) * (B)-floor((A) * (B)))
	float phi       = 2.0 * PI * madfrac(i, PHI - 1);
    float cos_theta = 1.0 - (2.0 * i + 1.0) * (1.0 / n);
    float sin_theta = sqrt(clamp(1.0 - cos_theta * cos_theta, 0.0, 1.0));
#undef madfrac
    return vec3(cos(phi) * sin_theta, sin(phi) * sin_theta, cos_theta);
}

vec3 indirect_lighting(vec3 V, vec3 N, vec3 P, vec3 F0, vec3 base_color, float roughness, float metallic)
{
	vec3 F = schlick_fresnel_roughness(max(dot(N, V), 0.0), F0, roughness);
	vec3 Ks = F;
	vec3 Kd = (1.0 - Ks) * (1.0 - metallic);
	return push_constants.gi_intensity * Kd * base_color * sample_irradiance(P, N, V, ddgi_buffer, probe_depth, probe_irradiance);
}

vec3 eval_diffuse_bsdf(ShadeState sstate, vec3 V, vec3 N, vec3 L)
{
	vec3 f = vec3(0.0);
	if(dot(N, L) < 0.0)
	{
		return vec3(0.0);
	}
	vec3 H = normalize(L + V);
	float m_pdf;
  	return eval_diffuse(sstate, V, N, L, H, m_pdf);
}

void main()
{
	const ivec2 pixel_coord = ivec2(gl_GlobalInvocationID.xy);
    const int ray_id = pixel_coord.x;
    const int probe_id = pixel_coord.y;

	prd.seed = tea(ddgi_buffer.rays_per_probe * gl_GlobalInvocationID.y + gl_GlobalInvocationID.x, push_constants.frame_count);

	Ray ray;
	ray.origin = probe_location(probe_id);
	ray.direction  = normalize(mat3(push_constants.random_orientation) * spherical_fibonacci(ray_id, ddgi_buffer.rays_per_probe));

	vec3 radiance = vec3(0);

	if(closest_hit(ray))
	{
		ShadeState sstate = get_shade_state(ray, prd);
		radiance += sstate.mat.emissive_factor;
		LightSample ls = sample_light(sstate);
		Ray shadow_ray;
		shadow_ray.origin = offset_ray(sstate.position, dot(ls.dir, sstate.ffnormal) > 0 ? sstate.ffnormal : -sstate.ffnormal);
		shadow_ray.direction = ls.dir;
		if(!any_hit(shadow_ray, length(shadow_ray.origin - ls.pos)))
		{
			vec3 f = eval_diffuse_bsdf(sstate, -ray.direction, sstate.ffnormal, ls.dir);
			radiance += f * ls.le * abs(dot(sstate.ffnormal, ls.dir)) / ls.pdf;
			radiance += f * abs(dot(sstate.ffnormal, -ray.direction)) * sample_irradiance(sstate.position, sstate.ffnormal, -ray.direction, ddgi_buffer, probe_depth, probe_irradiance);
		}
	}
	else
	{
		radiance = textureLod(skybox, ray.direction, 0.0).rgb;
	}

	imageStore(radiance_image, pixel_coord, vec4(radiance, 0.0));
    imageStore(direction_depth, pixel_coord, vec4(ray.direction, prd.hit_t));
}