#version 460

#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_shader_explicit_arithmetic_types : enable

#include "common.glsl"
#include "random.glsl"

#define NUM_THREADS_X 8
#define NUM_THREADS_Y 8

layout(local_size_x = NUM_THREADS_X, local_size_y = NUM_THREADS_Y, local_size_z = 1) in;

layout(set = 0, binding = 0) uniform sampler2D input_image;
layout(set = 1, binding = 0, rgba8) uniform image2D output_image;

layout(push_constant) uniform PushConstants
{
	float brightness;
	float contrast;
	float saturation;
	float vignette;
	float avg_lum;
	float y_white;
	float key;
}push_constants;

const float GAMMA     = 2.2;
const float INV_GAMMA = 1.0 / GAMMA;

vec3 linear_to_srgb(vec3 color)
{
  return pow(color, vec3(INV_GAMMA));
}

vec3 srgb_to_linear(vec3 srgb)
{
  return vec3(pow(srgb.xyz, vec3(GAMMA)));
}

vec4 srgb_to_linear(vec4 srgb)
{
  return vec4(srgb_to_linear(srgb.xyz), srgb.w);
}

vec3 uncharted2(vec3 color)
{
  const float A = 0.15;
  const float B = 0.50;
  const float C = 0.10;
  const float D = 0.20;
  const float E = 0.02;
  const float F = 0.30;
  return ((color * (A * color + C * B) + D * E) / (color * (A * color + B) + D * F)) - E / F;
}

vec3 tone_map_uncharted(vec3 color)
{
  const float W = 11.2;
  color = uncharted2(color * 2.0);
  vec3 white_scale = 1.0 / uncharted2(vec3(W));
  return linear_to_srgb(color * white_scale);
}

vec3 tonemap(vec3 color, float exposure)
{
	color *= exposure;
	return tone_map_uncharted(color);
}

vec3 dither(vec3 linear_color, vec3 noise, float quant)
{
	vec3 c0 = floor(linear_to_srgb(linear_color) / quant) * quant;
	vec3 c1 = c0 + quant;
	vec3 discr = mix(srgb_to_linear(c0), srgb_to_linear(c1), noise);
	return mix(c0, c1, lessThan(discr, linear_color));
}

void main()
{
	const ivec2 size = textureSize(input_image, 0);
	const ivec2 pos = ivec2(gl_GlobalInvocationID.xy);
	const vec2 pixel = vec2(pos) + vec2(0.5);
	vec2 uv = pixel / vec2(size);

	vec4 hdr = texture(input_image, uv).rgba;

	vec3 color = tonemap(hdr.rgb, push_constants.avg_lum);

	uvec3 r = pcg3d(uvec3(pos.xy, 0));
	vec3 noise = uintBitsToFloat(0x3f800000 | (r >> 9)) - 1.0;
	color = dither(srgb_to_linear(color), noise, 1.0 / 255.0);

	color = clamp(mix(vec3(0.5), color, push_constants.contrast), 0, 1);
	color = pow(color, vec3(1.0 / push_constants.brightness));
	color = mix(vec3(dot(color, vec3(0.299, 0.587, 0.114))), color, push_constants.saturation);

	uv = (uv - 0.5) * 2.0;
	color *= 1.0 - dot(uv, uv) * push_constants.vignette;

	imageStore(output_image, ivec2(gl_GlobalInvocationID.xy), vec4(color, hdr.a));
}