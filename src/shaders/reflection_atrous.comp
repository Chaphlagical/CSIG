#version 460
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_ray_query : enable
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_shader_explicit_arithmetic_types : enable
#extension GL_EXT_buffer_reference : enable
#extension GL_EXT_buffer_reference2 : enable

#include "scene.glsl"
#include "gbuffer_data.glsl"
#include "bxdf.glsl"
#define USE_EDGE_STOPPING_NORMAL_WEIGHT
#define USE_EDGE_STOPPING_LUMA_WEIGHT
#include "edge_stopping.glsl"

#define NUM_THREADS_X 8
#define NUM_THREADS_Y 8

layout (local_size_x = NUM_THREADS_X, local_size_y = NUM_THREADS_Y, local_size_z = 1) in;

layout(push_constant) uniform PushConstants
{
    uint64_t denoise_tile_data_addr;
    int gbuffer_mip;
    float phi_color;
    float phi_normal;
    int radius;
    int step_size;
    float sigma_depth;
}push_constants;

layout(set = 2, binding = 0, rgba16f) uniform writeonly image2D output_image;
layout(set = 2, binding = 1) uniform sampler2D input_image;

layout(buffer_reference, scalar, buffer_reference_align = 4) buffer TileDataBuffer
{
    ivec2 coord[];
};

float compute_variance_center(ivec2 ipos)
{
    float sum = 0.0;

    const float kernel[2][2] = {
        { 1.0 / 4.0, 1.0 / 8.0 },
        { 1.0 / 8.0, 1.0 / 16.0 }
    };

    const int radius = 1;
    for (int yy = -radius; yy <= radius; yy++)
    {
        for (int xx = -radius; xx <= radius; xx++)
        {
            ivec2 p = ipos + ivec2(xx, yy);
            float k = kernel[abs(xx)][abs(yy)];
            sum += texelFetch(input_image, p, 0).a * k;
        }
    }

    return sum;
}

void main()
{
    const ivec2 coord = ivec2(gl_GlobalInvocationID.xy);
    const ivec2 size = textureSize(gbufferA, push_constants.gbuffer_mip);
    const vec2 pixel_center = vec2(coord) + vec2(0.5);
    const vec2 tex_coord = pixel_center / vec2(size);

    const ivec2 ipos = TileDataBuffer(push_constants.denoise_tile_data_addr).coord[gl_WorkGroupID.x] + ivec2(gl_LocalInvocationID.xy);

    const float eps_variance = 1e-10;
    const float kernel_weights[3] = { 1.0, 2.0 / 3.0, 1.0 / 6.0 };

    const vec4  color_center = texelFetch(input_image, ipos, 0);
    const float center_color_luma = luminance(color_center.rgb);

    const float var = compute_variance_center(ipos);

    vec4 center_gbuffer_B = texelFetch(gbufferB, ipos, push_constants.gbuffer_mip);
    vec4 center_gbuffer_C = texelFetch(gbufferC, ipos, push_constants.gbuffer_mip);

    vec3 current_normal = octohedral_to_direction(center_gbuffer_B.xy);
    float center_depth = center_gbuffer_C.w;

    const float depth = texelFetch(depth_buffer, ipos, push_constants.gbuffer_mip).r;
    const float roughness = texelFetch(gbufferC, ipos, push_constants.gbuffer_mip).r;

    if (depth == 0.0)
    {
        imageStore(output_image, ipos, vec4(0.0));
        return;
    }
    else if ((roughness < MIRROR_REFLECTIONS_ROUGHNESS_THRESHOLD) || (roughness > DIFFUSE_REFLECTIONS_ROUGHNESS_THRESHOLD))
    {
        imageStore(output_image, ipos, color_center);
        return;
    }

    const float phi_color = push_constants.phi_color * sqrt(max(0.0, eps_variance + var.r));

    float sum_w_color = 1.0;
    vec4 sum_color = color_center;

    for (int yy = -push_constants.radius; yy <= push_constants.radius; yy++)
    {
        for (int xx = -push_constants.radius; xx <= push_constants.radius; xx++)
        {
            const ivec2 p      = ipos + ivec2(xx, yy) * push_constants.step_size;
            const bool  inside = all(greaterThanEqual(p, ivec2(0, 0))) && all(lessThan(p, size));
            const float kernel = kernel_weights[abs(xx)] * kernel_weights[abs(yy)];

            if (inside && (xx != 0 || yy != 0)) // skip center pixel, it is already accumulated
            {
                const vec4  sample_color      = texelFetch(input_image, p, 0);
                const float sample_color_luma = luminance(sample_color.rgb);

                vec4 sample_gbuffer_B = texelFetch(gbufferB, p, push_constants.gbuffer_mip);
                vec4 sample_gbuffer_C = texelFetch(gbufferC, p, push_constants.gbuffer_mip);

                vec3  sample_normal = octohedral_to_direction(sample_gbuffer_B.xy);
                float sample_depth  = sample_gbuffer_C.w;

                // compute the edge-stopping functions
                const float w = compute_edge_stopping_weight(center_depth,
                                                             sample_depth,
                                                             push_constants.sigma_depth,
                                                             current_normal,
                                                             sample_normal,
                                                             push_constants.phi_normal,
                                                             center_color_luma,
                                                             sample_color_luma,
                                                             phi_color);

                const float w_color = w * kernel;

                // alpha channel contains the variance, therefore the weights need to be squared, see paper for the formula
                sum_w_color += w_color;
                sum_color += vec4(vec3(w_color), w_color * w_color) * sample_color;
            }
        }
    }

    vec4 out_color = sum_color / vec4(vec3(sum_w_color), sum_w_color * sum_w_color);

    imageStore(output_image, ipos, out_color);
}