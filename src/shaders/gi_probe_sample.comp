#version 460

#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_ray_query : enable
#extension GL_EXT_nonuniform_qualifier : enable

#include "common.glsl"

#define NUM_THREADS_X 8
#define NUM_THREADS_Y 8

layout(local_size_x = NUM_THREADS_X, local_size_y = NUM_THREADS_Y, local_size_z = 1) in;

layout(binding = 0) uniform UBO
{
	mat4 view_inv;
	mat4 projection_inv;
	mat4 view_projection_inv;
	mat4 view_projection;
	mat4 prev_view_projection;
	vec4 cam_pos;
	vec4 jitter;
} ubo;

layout(binding = 1) uniform DDGIBuffer
{
    vec3 grid_start;
    float max_distance;
    vec3 grid_step;
    float depth_sharpness;
    ivec3 probe_count;
    float hysteresis;
    float normal_bias;
    float energy_preservation;
    uint rays_per_probe;
    uint visibility_test;
    uint irradiance_probe_side_length;
    uint irradiance_texture_width;
    uint irradiance_texture_height;
    uint depth_probe_side_length;
    uint depth_texture_width;
    uint depth_texture_height;
} ddgi_buffer;

layout(binding = 2) uniform sampler2D gbufferB;
layout(binding = 3) uniform sampler2D depth_buffer;
layout(binding = 4) uniform sampler2D probe_irradiance;
layout(binding = 5) uniform sampler2D probe_depth;
layout(binding = 6, rgba16f) uniform image2D output_gi;

layout(push_constant) uniform PushConstants
{
	int gbuffer_mip;
    float gi_intensity;
}push_constants;

const float FLT_EPS = 0.00000001;

ivec3 base_grid_coord(vec3 X) 
{
    return clamp(ivec3((X - ddgi_buffer.grid_start) / ddgi_buffer.grid_step), ivec3(0, 0, 0), ivec3(ddgi_buffer.probe_count) - ivec3(1, 1, 1));
}

vec3 grid_coord_to_position(ivec3 c)
{
    return ddgi_buffer.grid_step * vec3(c) + ddgi_buffer.grid_start;
}

int grid_coord_to_probe_index(ivec3 probe_coord) 
{
    return int(probe_coord.x + probe_coord.y * ddgi_buffer.probe_count.x + probe_coord.z * ddgi_buffer.probe_count.x * ddgi_buffer.probe_count.y);
}

float sign_not_zero(in float k)
{
    return (k >= 0.0) ? 1.0 : -1.0;
}

vec2 sign_not_zero(in vec2 v)
{
    return vec2(sign_not_zero(v.x), sign_not_zero(v.y));
}

vec2 oct_encode(in vec3 v) 
{
    float l1norm = abs(v.x) + abs(v.y) + abs(v.z);
    vec2 result = v.xy * (1.0 / l1norm);
    if (v.z < 0.0)
    {
        result = (1.0 - abs(result.yx)) * sign_not_zero(result.xy);
    }
    return result;
}

vec2 texture_coord_from_direction(vec3 dir, int probe_index, uint width, uint height, uint probe_side_length) 
{
    vec2 normalized_oct_coord = oct_encode(normalize(dir));
    vec2 normalized_oct_coord_zero_one = (normalized_oct_coord + vec2(1.0)) * 0.5;

    float probe_with_border_side = float(probe_side_length) + 2.0;

    vec2 oct_coord_normalized_to_texture_dimensions = (normalized_oct_coord_zero_one * float(probe_side_length)) / vec2(float(width), float(height));

    int probes_per_row = (int(width) - 2) / int(probe_with_border_side);

    vec2 probe_top_left_position = vec2(mod(probe_index, probes_per_row) * probe_with_border_side,
        (probe_index / probes_per_row) * probe_with_border_side) + vec2(2.0, 2.0);

    vec2 normalized_probe_top_left_position = vec2(probe_top_left_position) / vec2(float(width), float(height));

    return vec2(normalized_probe_top_left_position + oct_coord_normalized_to_texture_dimensions);
}

vec3 sample_irradiance(vec3 P, vec3 N, vec3 V)
{
    ivec3 base_grid_coord = base_grid_coord(P);
    vec3 base_probe_pos = grid_coord_to_position(base_grid_coord);

    vec3 sum_irradiance = vec3(0.0);
    float sum_weight = 0.0;

    vec3 alpha = clamp((P - base_probe_pos) / ddgi_buffer.grid_step, vec3(0.0), vec3(1.0));

    for (int i = 0; i < 8; ++i) 
    {
        ivec3 offset = ivec3(i, i >> 1, i >> 2) & ivec3(1);
        ivec3 probe_grid_coord = clamp(base_grid_coord + offset, ivec3(0), ddgi_buffer.probe_count - ivec3(1));
        int p = grid_coord_to_probe_index(probe_grid_coord);
        vec3 probe_pos = grid_coord_to_position(probe_grid_coord);
        vec3 probe_to_point = P - probe_pos + (N + 3.0 * V) * ddgi_buffer.normal_bias;
        vec3 dir = normalize(-probe_to_point);
        vec3 trilinear = mix(1.0 - alpha, alpha, offset);
        vec3 true_direction_to_probe = normalize(probe_pos - P);
        float weight = pow(max(0.0001, (dot(true_direction_to_probe, N) + 1.0) * 0.5), 2.0) + 0.2;
        if (ddgi_buffer.visibility_test == 1)
        {
            vec2 tex_coord = texture_coord_from_direction(-dir, p, ddgi_buffer.depth_texture_width, ddgi_buffer.depth_texture_height, ddgi_buffer.depth_probe_side_length);

            float dist_to_probe = length(probe_to_point);

            vec2 temp = textureLod(probe_depth, tex_coord, 0.0f).rg;
            float mean = temp.x;
            float variance = abs(pow(temp.x, 2.0) - temp.y);

            float chebyshev_weight = variance / (variance + pow(max(dist_to_probe - mean, 0.0), 2.0));

            chebyshev_weight = max(pow(chebyshev_weight, 3.0), 0.0);

            weight *= (dist_to_probe <= mean) ? 1.0 : chebyshev_weight;
        }

        weight = max(0.000001, weight);
                 
        vec3 irradiance_dir = dot(N, V) > 0 ? N : -N;

        vec2 tex_coord = texture_coord_from_direction(normalize(irradiance_dir), p, ddgi_buffer.irradiance_texture_width, ddgi_buffer.irradiance_texture_height, ddgi_buffer.irradiance_probe_side_length);

        vec3 probe_irradiance = textureLod(probe_irradiance, tex_coord, 0.0).rgb;

        const float crush_threshold = 0.2;
        if (weight < crush_threshold)
        {
            weight *= weight * weight * (1.0 / pow(crush_threshold, 2.0)); 
        }

        weight *= trilinear.x * trilinear.y * trilinear.z;

        sum_irradiance += weight * probe_irradiance;
        sum_weight += weight;
    }

    vec3 net_irradiance = sum_irradiance / sum_weight;
    
    net_irradiance.x = isnan(net_irradiance.x) ? 0.5 : net_irradiance.x;
    net_irradiance.y = isnan(net_irradiance.y) ? 0.5 : net_irradiance.y;
    net_irradiance.z = isnan(net_irradiance.z) ? 0.5 : net_irradiance.z;

    net_irradiance *= ddgi_buffer.energy_preservation;

    return 0.5 * PI * net_irradiance;
}

void main()
{
    const ivec2 size = textureSize(gbufferB, push_constants.gbuffer_mip);
    const vec2 texel_size = vec2(1.0) / vec2(size);
    const ivec2 current_coord = ivec2(gl_GlobalInvocationID.xy);
    const vec2 pixel_center = vec2(current_coord) + vec2(0.5);
    const vec2 tex_coord = pixel_center / vec2(size);

    float depth = texelFetch(depth_buffer, current_coord, push_constants.gbuffer_mip).r;

    if (depth == 1.0)
    {
        imageStore(output_gi, current_coord, vec4(0.0));
        return;
    }

    vec3 P  = world_position_from_depth(tex_coord, depth, ubo.view_projection_inv);
    vec3 N  = octohedral_to_direction(texelFetch(gbufferB, current_coord, push_constants.gbuffer_mip).rg);
    vec3 V = normalize(ubo.cam_pos.xyz - P);
    N = dot(N, V) > 0 ? N : -N;

    vec3 irradiance = push_constants.gi_intensity * sample_irradiance(P, N, V);

    imageStore(output_gi, current_coord, vec4(irradiance, 1.0));
}