#version 460
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_ray_query : enable
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_shader_explicit_arithmetic_types : enable
#extension GL_EXT_buffer_reference : enable
#extension GL_EXT_buffer_reference2 : enable

#define NUM_THREADS_X 8
#define NUM_THREADS_Y 8

#include "random.glsl"
#include "gbuffer_data.glsl"
#include "scene.glsl"
#include "raytrace.glsl"
#include "bxdf.glsl"
#include "bluenoise.glsl"
#include "spherical_harmonic.glsl"
#include "ddgi.glsl"

layout (local_size_x = NUM_THREADS_X, local_size_y = NUM_THREADS_Y, local_size_z = 1) in;

layout(set = 3, binding = 0) uniform sampler2D ggx_preintegration;
layout(set = 4, binding = 0, scalar) uniform DDGIUBO
{
    DDGIUniform ddgi_buffer;
};
layout(set = 4, binding = 1) uniform sampler2D probe_irradiance;
layout(set = 4, binding = 2) uniform sampler2D probe_depth;
layout(set = 5, binding = 0, rgba16f) uniform image2D raytrace_image;

layout(push_constant) uniform PushConstants
{
    int gbuffer_mip;
}push_constants;

vec4 importance_sample_ggx(vec2 E, vec3 N, float roughness)
{
    float a  = roughness * roughness;
    float m2 = a * a;

    float phi      = 2.0 * PI * E.x;
    float cos_theta = sqrt((1.0 - E.y) / (1.0 + (m2 - 1.0) * E.y));
    float sin_theta = sqrt(1.0 - cos_theta * cos_theta);

    vec3 H;
    H.x = cos(phi) * sin_theta;
    H.y = sin(phi) * sin_theta;
    H.z = cos_theta;

    float d = (cos_theta * m2 - cos_theta) * cos_theta + 1;
    float D = m2 / (PI * d * d);

    float pdf = D * cos_theta;

    vec3 up        = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);
    vec3 tangent   = normalize(cross(up, N));
    vec3 bitangent = cross(N, tangent);

    vec3 sample_vec = tangent * H.x + bitangent * H.y + N * H.z;
    return vec4(normalize(sample_vec), pdf);
}

vec3 indirect_lighting(ShadeState sstate, vec3 wo, vec3 wi)
{
    vec3 F0 = mix(vec3(0), sstate.mat.base_color.rgb, sstate.mat.metallic_factor);
    vec3 F = F0 + (max(vec3(1.0 - sstate.mat.roughness_factor), F0) * pow(1.0 - max(dot(sstate.ffnormal, wo), 0.0), 5.0));
    vec3 Kd = (1.0 - F) * (1.0 - sstate.mat.metallic_factor);
    vec3 diffuse = sstate.mat.base_color.rgb * sample_irradiance(sstate.position, sstate.ffnormal, wo, ddgi_buffer, probe_depth, probe_irradiance);
    vec3 prefiltered_color = textureLod(prefilter_map, wi, sstate.mat.roughness_factor * PREFILTER_MIP_LEVELS).rgb;
    vec2 brdf = textureLod(ggx_preintegration, vec2(clamp(abs(dot(wo, sstate.ffnormal)), 0.0, 1.0), sstate.mat.roughness_factor), 0).rg;
    vec3 specular = prefiltered_color * (F * brdf.x + brdf.y);
    vec3 radiance = Kd * diffuse + specular;
    return radiance;
}

vec3 direct_lighting(ShadeState sstate, vec3 wo)
{
    const uint light_samples = 5;
    vec3 radiance = vec3(0);
    uint sample_count = 0;
    for(uint i = 0; i < light_samples; i++)
    {
        LightSample ls = sample_light(sstate);
        Ray shadow_ray;
        shadow_ray.origin = offset_ray(sstate.position, dot(ls.dir, sstate.ffnormal) > 0 ? sstate.ffnormal : -sstate.ffnormal);
        shadow_ray.direction = ls.dir;
        if(ls.pdf > 0)
        {
            float bsdf_pdf;
            vec3 f = eval_bsdf(sstate, wo, sstate.ffnormal, ls.dir, bsdf_pdf);
            radiance += f * ls.le * abs(dot(sstate.ffnormal, ls.dir)) / ls.pdf;
            sample_count += 1;
        }
    }
    if(sample_count > 0)
    {
        radiance /= float(sample_count);
    }
    return any(isnan(radiance)) ? vec3(0) : radiance;
}

vec3 trace_reflection(Ray reflection_ray, vec3 wo, ShadeState sstate, out float ray_length)
{
    vec3 radiance = vec3(0);
    if(closest_hit(reflection_ray))
    {
        ShadeState reflection_sstate = get_shade_state(reflection_ray, prd);
        radiance += reflection_sstate.mat.emissive_factor;
        radiance += direct_lighting(reflection_sstate, -reflection_ray.direction);
        vec3 H = importance_sample_GTR2(reflection_sstate.mat.roughness_factor, rand(prd.seed), rand(prd.seed));
        H = reflection_sstate.tangent * H.x + reflection_sstate.bitangent * H.y + reflection_sstate.ffnormal * H.z;
        vec3 wi = normalize(reflect(reflection_ray.direction, H));
        radiance += reflection_sstate.mat.base_color.rgb * abs(dot(wi, H)) * sample_irradiance(reflection_sstate.position, sstate.ffnormal, wi, ddgi_buffer, probe_depth, probe_irradiance);
        ray_length = prd.hit_t;
    }
    else
    {
        radiance += indirect_lighting(sstate, wo, reflection_ray.direction);
        ray_length = -1.0;
    }
    return radiance;
}

void main()
{
    const ivec2 coord = ivec2(gl_GlobalInvocationID.xy);
    const ivec2 size = textureSize(gbufferA, push_constants.gbuffer_mip);
    const vec2 pixel_center = vec2(coord) + vec2(0.5);
    const vec2 tex_coord = pixel_center / vec2(size);

	prd.seed = tea(size.x * gl_GlobalInvocationID.y + gl_GlobalInvocationID.x, uint(ubo.cam_pos.w));

    vec3 radiance = vec3(0);
    float ray_length = 0.0;

    ShadeState sstate;
    if(get_primary_state(vec2(coord) + vec2(0.5), push_constants.gbuffer_mip, sstate))
    {
        vec3 wo = normalize(ubo.cam_pos.xyz - sstate.position);
        float ray_length = -1.0;
        Ray ray;
        {
            if(sstate.mat.roughness_factor <= MIRROR_REFLECTIONS_ROUGHNESS_THRESHOLD)
            {
                ray.direction = reflect(-wo, sstate.ffnormal);
                ray.origin =  sstate.position + 0.1 * (dot(ray.direction, sstate.ffnormal) > 0 ? sstate.ffnormal : -sstate.ffnormal);
                radiance += trace_reflection(ray, wo, sstate, ray_length);
            }
            if(sstate.mat.roughness_factor > DIFFUSE_REFLECTIONS_ROUGHNESS_THRESHOLD)
            {
                radiance += sample_irradiance(sstate.position, sstate.ffnormal, normalize(reflect(-wo, sstate.ffnormal)), ddgi_buffer, probe_depth, probe_irradiance);
            }
            else
            {
                vec3 H = importance_sample_GTR2(sstate.mat.roughness_factor, rand(prd.seed), rand(prd.seed));
                H = normalize(sstate.tangent * H.x + sstate.bitangent * H.y + sstate.ffnormal * H.z);
                ray.direction = normalize(reflect(-wo, H));
		        ray.origin = sstate.position + 0.01 * (dot(ray.direction, sstate.ffnormal) > 0 ? sstate.ffnormal : -sstate.ffnormal);
                radiance += trace_reflection(ray, wo, sstate, ray_length);
            }
        }
        vec3 clamped_color = min(radiance, vec3(0.7));
        imageStore(raytrace_image, coord, vec4(clamped_color, ray_length));
    }
    else
    {
        imageStore(raytrace_image, coord, vec4(0, 0, 0, -1.0));
    }
}