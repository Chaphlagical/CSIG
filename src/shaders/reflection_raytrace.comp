#version 460
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_ray_query : enable
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_shader_explicit_arithmetic_types : enable
#extension GL_EXT_buffer_reference : enable
#extension GL_EXT_buffer_reference2 : enable

#define NUM_THREADS_X 8
#define NUM_THREADS_Y 8

#include "random.glsl"
#include "gbuffer_data.glsl"
#include "scene.glsl"
#include "raytrace.glsl"
#include "bxdf.glsl"
#include "bluenoise.glsl"
#include "spherical_harmonic.glsl"

layout (local_size_x = NUM_THREADS_X, local_size_y = NUM_THREADS_Y, local_size_z = 1) in;

layout(set = 3, binding = 0) uniform sampler2D ggx_preintegration;
layout(set = 4, binding = 0, rgba16f) uniform image2D raytrace_image;

layout(push_constant) uniform PushConstants
{
    int gbuffer_mip;
}push_constants;

vec4 importance_sample_ggx(vec2 E, vec3 N, float roughness)
{
    float a  = roughness * roughness;
    float m2 = a * a;

    float phi      = 2.0 * PI * E.x;
    float cos_theta = sqrt((1.0 - E.y) / (1.0 + (m2 - 1.0) * E.y));
    float sin_theta = sqrt(1.0 - cos_theta * cos_theta);

    vec3 H;
    H.x = cos(phi) * sin_theta;
    H.y = sin(phi) * sin_theta;
    H.z = cos_theta;

    float d = (cos_theta * m2 - cos_theta) * cos_theta + 1;
    float D = m2 / (PI * d * d);

    float pdf = D * cos_theta;

    vec3 up        = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);
    vec3 tangent   = normalize(cross(up, N));
    vec3 bitangent = cross(N, tangent);

    vec3 sample_vec = tangent * H.x + bitangent * H.y + N * H.z;
    return vec4(normalize(sample_vec), pdf);
}

vec3 indirect_lighting(ShadeState sstate, vec3 wo, vec3 wi)
{
    vec3 radiance = vec3(0);
    vec3 F0 = mix(vec3(0), sstate.mat.base_color.rgb, sstate.mat.metallic_factor);
    vec3 F = F0 + (max(vec3(1.0 - sstate.mat.roughness_factor), F0) * pow(1.0 - max(dot(sstate.ffnormal, wo), 0.0), 5.0));
    vec3 Kd = (1.0 - F) * (1.0 - sstate.mat.metallic_factor);
    vec3 irradiance = vec3(0.0);
    SH9 basis = evaluate_sh(sstate.ffnormal);
    for (uint i = 0; i < 9; i++)
    {
        irradiance += texelFetch(irradiance_sh, ivec2(i, 0), 0).rgb * basis.weights[i];
    }
    irradiance = max(vec3(0), irradiance) * InvPI;
    vec3 diffuse = irradiance * sstate.mat.base_color.rgb;
    radiance += Kd * diffuse;
    vec3 prefiltered_color = textureLod(prefilter_map, wi, sstate.mat.roughness_factor * PREFILTER_MIP_LEVELS).rgb;
    vec2 brdf = textureLod(ggx_preintegration, vec2(1.0 - clamp(abs(dot(wo, sstate.ffnormal)), 0.0, 1.0), sstate.mat.roughness_factor), 0).rg;
    vec3 specular = prefiltered_color * (F * brdf.x + brdf.y);
    radiance += specular;

    return radiance;
}

vec3 direct_lighting(ShadeState sstate, vec3 wo)
{
    const uint light_samples = 5;
    vec3 radiance = vec3(0);
    uint sample_count = 0;
    for(uint i = 0; i < light_samples; i++)
    {
        LightSample ls = sample_light(sstate);
        if(ls.pdf > 0)
        {
            float bsdf_pdf;
            vec3 f = eval_bsdf(sstate, wo, sstate.ffnormal, ls.dir, bsdf_pdf);
            radiance += f * ls.le / ls.pdf;
            sample_count += 1;
        }
    }
    return radiance / float(sample_count);
}

vec3 trace_reflection(Ray reflection_ray, vec3 wo, ShadeState sstate)
{
    vec3 radiance = vec3(0);
    if(closest_hit(reflection_ray))
    {
        ShadeState reflection_sstate = get_shade_state(reflection_ray, prd);
        radiance += reflection_sstate.mat.emissive_factor;
        
        radiance += direct_lighting(reflection_sstate, -reflection_ray.direction);
        vec3 H = importance_sample_GTR2(reflection_sstate.mat.roughness_factor, rand(prd.seed), rand(prd.seed));
        H = reflection_sstate.tangent * H.x + reflection_sstate.bitangent * H.y + reflection_sstate.ffnormal * H.z;
        radiance += indirect_lighting(reflection_sstate, -reflection_ray.direction, normalize(reflect(reflection_ray.direction, H)));
    }
    else
    {
        radiance += indirect_lighting(sstate, wo, reflection_ray.direction);
    }
    return radiance;
}

void main()
{
    const ivec2 coord = ivec2(gl_GlobalInvocationID.xy);
    const ivec2 size = textureSize(gbufferA, push_constants.gbuffer_mip);
    const vec2 pixel_center = vec2(coord) + vec2(0.5);
    const vec2 tex_coord = pixel_center / vec2(size);

	prd.seed = tea(size.x * gl_GlobalInvocationID.y + gl_GlobalInvocationID.x, uint(ubo.cam_pos.w));

    vec3 radiance = vec3(0);
    float ray_length = 0.0;

    ShadeState sstate;
    if(get_primary_state(vec2(coord) + vec2(0.5), push_constants.gbuffer_mip, sstate))
    {
        vec3 wo = normalize(ubo.cam_pos.xyz - sstate.position);
        Ray ray;
        {
            if(sstate.mat.roughness_factor <= MIRROR_REFLECTIONS_ROUGHNESS_THRESHOLD)
            {
                ray.direction = reflect(-wo, sstate.ffnormal);
                ray.origin =  sstate.position + 0.01 * (dot(ray.direction, sstate.ffnormal) > 0 ? sstate.ffnormal : -sstate.ffnormal);
                radiance += trace_reflection(ray, wo, sstate);
            }
            else if(sstate.mat.roughness_factor > DIFFUSE_REFLECTIONS_ROUGHNESS_THRESHOLD)
            {
                // Sample DDGI
            }
            else
            {
                vec3 H = importance_sample_GTR2(sstate.mat.roughness_factor, rand(prd.seed), rand(prd.seed));
                H = normalize(sstate.tangent * H.x + sstate.bitangent * H.y + sstate.ffnormal * H.z);
                ray.direction = normalize(reflect(-wo, H));
		        ray.origin = sstate.position + 0.01 * (dot(ray.direction, sstate.ffnormal) > 0 ? sstate.ffnormal : -sstate.ffnormal);
                radiance += trace_reflection(ray, wo, sstate);
            }
        }
        
        imageStore(raytrace_image, coord, vec4(radiance, 1));
    }
    else
    {
        imageStore(raytrace_image, coord, vec4(textureLod(skybox, normalize(sstate.position - ubo.cam_pos.xyz), 0).rgb, 1.0));
    }
}