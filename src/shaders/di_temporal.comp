#version 460
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_ray_query : enable
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_shader_explicit_arithmetic_types : enable
#extension GL_EXT_buffer_reference : enable
#extension GL_EXT_buffer_reference2 : enable

#define NUM_THREADS_X 8
#define NUM_THREADS_Y 8

#include "restir_common.glsl"
#include "gbuffer_data.glsl"
#include "scene.glsl"
#include "raytrace.glsl"
#include "bxdf.glsl"

layout (local_size_x = NUM_THREADS_X, local_size_y = NUM_THREADS_Y, local_size_z = 1) in;

layout(push_constant) uniform PushConstants
{
	uint64_t temporal_reservoir_addr;
	uint64_t passthrough_reservoir_addr;
    uint temporal_reuse;
    int M;
}push_constants;

void main()
{
	const ivec2 coord = ivec2(gl_GlobalInvocationID.xy);
    const ivec2 size = textureSize(gbufferA, 0);
    const uint pixel_id = coord.x * size.y + coord.y;

    if(coord.x >= size.x || coord.y >= size.y)
    {
        return;
    }

    RestirReservoirBuffer(push_constants.passthrough_reservoir_addr).reservoirs[pixel_id] = init_reservoir();
    barrier();

    prd.seed = tea(size.x * gl_GlobalInvocationID.y + gl_GlobalInvocationID.x, uint(ubo.cam_pos.w));

    Reservoir r = init_reservoir();

    ShadeState sstate;
    if(get_primary_state(vec2(coord) + vec2(0.5), 0, sstate))
    {
        const uint light_samples = min(scene_data.emitter_count, push_constants.M);

        for (uint i = 0; i < light_samples; i++)
        {
            LightSample ls = sample_light(sstate);
            float p_hat = eval_phat(ls.id, sstate);
            add_sample_to_reservoir(r, int(ls.id), ls.pdf, p_hat);
        }

        // Visibility check
        if(r.num_samples > 0)
        {
            LightSample ls = sample_light_idx(sstate, r.light_id);
            Ray shadow_ray;
            shadow_ray.origin = offset_ray(sstate.position, dot(ls.dir, sstate.ffnormal) > 0 ? sstate.ffnormal : -sstate.ffnormal);
			shadow_ray.direction = ls.dir;
			if(any_hit(shadow_ray, length(shadow_ray.origin - ls.pos)))
			{
                r.w = 0.0;
                r.sum_weights = 0.0;
			}
        }

        if(push_constants.temporal_reuse == 1)
        {
            vec4 ndc = ubo.prev_view_projection * vec4(sstate.position, 1.0f);
            ndc /= ndc.w;
            vec2 prev_frame_pos = (ndc.xy + vec2(1)) * 0.5 * vec2(size);
            if (all(greaterThan(prev_frame_pos.xy, vec2(0.0))) &&
			    all(lessThan(prev_frame_pos.xy, vec2(size))))
            {
                ShadeState prev_sstate;
                if(get_prev_primary_state(vec2(uvec2(prev_frame_pos.xy)), 0, prev_sstate))
                {
                    vec3 pos_diff = sstate.position - prev_sstate.position;
                    if(dot(pos_diff, pos_diff) < 0.01 && 
                        abs(sstate.depth - prev_sstate.depth) < prev_sstate.depth * 0.001)
                    {
                        vec3 base_color_diff = sstate.mat.base_color.rgb - prev_sstate.mat.base_color.rgb;
                        if(dot(base_color_diff, base_color_diff) < 0.01)
                        {
                            float normal_dot = dot(sstate.ffnormal, prev_sstate.ffnormal);
                            if(normal_dot > 0.5)
                            {
                                const uint prev_idx = uint(prev_frame_pos.x) * size.y + uint(prev_frame_pos.y);
                                Reservoir prev_r = get_reservoir(push_constants.temporal_reservoir_addr, prev_idx);
                                prev_r.num_samples = min(prev_r.num_samples, 20 * r.num_samples);
                                if(prev_r.num_samples > 0)
                                {
                                    float p_hat = eval_phat(prev_r.light_id, sstate);
                                    combine_reservoir(r, prev_r, p_hat);
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    RestirReservoirBuffer(push_constants.passthrough_reservoir_addr).reservoirs[pixel_id] = r;

}
